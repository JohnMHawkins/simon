// webber - WebServer package
//
// Copyright (c) 2018 - John M. Hawkins <jmhawkins@msn.com>
//
// All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
// associated documentation files (the "Software"), to deal in the Software without restriction, 
// including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial 
// portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

package webber

import (
	"fmt"
	"net/http"
	"time"
	//"strings"
	//"encoding/json"
	"bytes"
	"jmh/goweb/logger"
)
 

type HttpClient struct {
	transport *http.Transport
	client *http.Client
	preserveHeaders []string		// array of headers that should be preserved from upstream
}


func NewHttpClient (preserveHeaders []string) (*HttpClient) {

	r := new(HttpClient)
	r.transport = &http.Transport{
		MaxIdleConns: 10,
		IdleConnTimeout: 30 * time.Second,
		DisableCompression: true,
	}
	
	r.client = &http.Client{Transport: r.transport}
	if (preserveHeaders != nil && len(preserveHeaders) > 0) {
		r.preserveHeaders = make([]string, len(preserveHeaders) + 1 )
		r.preserveHeaders[0] = CORRELATION_ID_HEADER
		for i:= 0; i < len(preserveHeaders); i++ {
			r.preserveHeaders[i+1] = preserveHeaders[i]
		}

	} else {
		r.preserveHeaders = []string{CORRELATION_ID_HEADER}
	}
	return r
}

// Get will create a GET request to the specified url, preserving appropriate headers
// from the upstream request, if one is provided
//
// Parameters:
//	url : 	the destination url to fetch, including any query parameters
//	upstream : (optional) an upstream request that we should preserve information (such as headers, sessions, etc) from
//
// Returns:
//	*http.Response : the response of the call
//	error : any error generated by the attemp (note that non-200 errors are handled withing the response, not the error)
//
func (c *HttpClient) Get(url string, upstream *http.Request) (*http.Response, error) {

	req, err := http.NewRequest("GET", url, nil)
	if (err != nil) {
		return nil, err
	} else {
		// check for headers to preserve
		if ( upstream != nil ) {
			if ( c.preserveHeaders != nil ) {
				for _, k := range c.preserveHeaders {
					h := upstream.Header.Get(k)
					if ( len(h) > 0 ) {
						// TODO = should this be Add or Set?  
						req.Header.Add(k, h)
					}
				}
			}
		}
		// log outbound request
		logger.StdLogger.LOG(logger.INFO, getCorrelationId(req), fmt.Sprintf("outbound request %s", formatReqForLog(req)), nil)
		return c.client.Do(req)
	}

}

// Post will create a POST request to the specified url, preserving appropriate headers
// from the upstream request, if one is provided
//
// Parameters:
//	url : 	the destination url to fetch, including any query parameters
// 	data : 	the post data to send
//	contentType : the content type (e.g. application/json) to set in the header
//	upstream : (optional) an upstream request that we should preserve information (such as headers, sessions, etc) from
//
// Returns:
//	*http.Response : the response of the call
//	error : any error generated by the attemp (note that non-200 errors are handled withing the response, not the error)
//
func (c*HttpClient) Post(url string, data []byte, contentType string, upstream *http.Request) (*http.Response, error) {

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(data))
	if (err != nil) {
		return nil, err
	} else {
		// check for headers to preserve
		if ( upstream != nil ) {
			if ( c.preserveHeaders != nil ) {
				for _, k := range c.preserveHeaders {
					h := upstream.Header.Get(k)
					if ( len(h) > 0 ) {
						// TODO = should this be Add or Set?  
						req.Header.Add(k, h)
					}
				}
			}
		}
		if len(contentType) > 0 {
			req.Header.Set("Content-Type", contentType)
		}
		// log outbound request
		logger.StdLogger.LOG(logger.INFO, getCorrelationId(req), fmt.Sprintf("outbound request %s", formatReqForLog(req)), nil)
		return c.client.Do(req)
	}

}